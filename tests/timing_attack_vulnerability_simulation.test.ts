import { constantTimeCompare } from '../src/constant_time';
import * as crypto from 'crypto';

describe('Timing Attack Vulnerability Simulation 🏴‍☠️', () => {
    // Simulate a vulnerable (non-constant-time) comparison function
    function vulnerableCompare(a: string | Buffer, b: string | Buffer): boolean {
        const strA = typeof a === 'string' ? a : a.toString();
        const strB = typeof b === 'string' ? b : b.toString();

        // This is vulnerable to timing attacks because it returns early on first mismatch
        if (strA.length !== strB.length) {
            return false;
        }

        for (let i = 0; i < strA.length; i++) {
            if (strA[i] !== strB[i]) {
                return false; // Early return - timing attack vulnerability! ⚠️☠️🚨
            }
        }

        return true;
    }

    it('should demonstrate timing attack vulnerability with non-constant-time comparison', () => {
        const secret = 'super-secret-key-12345';

        // Test cases that would have different timing characteristics in vulnerable comparison
        const testCases = [
            'x',                           // Fails at first character
            'super-x',                     // Fails at 7th character  
            'super-secret-x',              // Fails at 14th character
            'super-secret-key-x',          // Fails at 19th character
            'super-secret-key-123x',       // Fails at 21st character
            'super-secret-key-12345',      // Matches completely
        ];

        testCases.forEach((testCase) => {
            const isVulnerableMatch = vulnerableCompare(secret, testCase);
            const isConstantTimeMatch = constantTimeCompare(secret, testCase);

            // Both should give the same result
            expect(isVulnerableMatch).toBe(isConstantTimeMatch);

            // Only the exact match should return true
            if (testCase === secret) {
                expect(isConstantTimeMatch).toBe(true);
            } else {
                expect(isConstantTimeMatch).toBe(false);
            }
        });
    });

    it('should demonstrate timing consistency with constant-time comparison', () => {
        const secret = Buffer.from('cryptographic-secret-value');
        const iterations = 100;

        // Test with different failure points
        const testCases = [
            Buffer.from('a'),                                   // Different length, fails immediately
            Buffer.from('cryptographic-a'),                     // Fails at position 14
            Buffer.from('cryptographic-secret-a'),              // Fails at position 22
            Buffer.from('cryptographic-secret-value'),          // Exact match
        ];

        testCases.forEach((testCase) => {
            const timings: number[] = [];

            // Measure timing for multiple iterations
            for (let i = 0; i < iterations; i++) {
                const start = process.hrtime.bigint();
                const result = constantTimeCompare(secret, testCase);
                const end = process.hrtime.bigint();

                timings.push(Number(end - start));

                // Verify correctness
                expect(result).toBe(testCase.equals(secret));
            }

            // Calculate timing statistics
            const avgTime = timings.reduce((sum, time) => sum + time, 0) / timings.length;
            const maxTime = Math.max(...timings);
            const minTime = Math.min(...timings);

            // In a proper constant-time implementation, timing variance should be minimal
            // Note: This is a demonstration - actual timing analysis would require more sophisticated tools
            // Allow for significant system variance as timing can be affected by many factors
            // The important aspect is that the function is implemented in a way that avoids early returns
            expect(maxTime - minTime).toBeLessThan(avgTime * 100); // This can be challenging due to testing on different hardware.
        });
    });

    it('should simulate protection against cryptographic timing attacks', () => {
        // Simulate a scenario where an attacker might try to guess a cryptographic key
        const actualKey = crypto.randomBytes(32);
        const keyHex = actualKey.toString('hex');

        // Simulate attacker attempts with partial knowledge
        const attackerGuesses = [
            keyHex.substring(0, 4) + 'x'.repeat(keyHex.length - 4),    // Knows first 4 chars
            keyHex.substring(0, 8) + 'x'.repeat(keyHex.length - 8),    // Knows first 8 chars
            keyHex.substring(0, 16) + 'x'.repeat(keyHex.length - 16),  // Knows first 16 chars
            keyHex.substring(0, 32) + 'x'.repeat(keyHex.length - 32),  // Knows first 32 chars
            keyHex,                                                    // Correct key
        ];

        attackerGuesses.forEach((guess) => {
            const isMatch = constantTimeCompare(keyHex, guess);

            // Only the exact match should succeed
            if (guess === keyHex) {
                expect(isMatch).toBe(true);
            } else {
                expect(isMatch).toBe(false);
            }
        });
    });

    it('should demonstrate timing attack protection with different data types', () => {
        const sensitiveData = {
            password: 'highly-sensitive-password',
            token: Buffer.from('secure-authentication-token'),
            hash: new Uint8Array([0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f]),
        };

        // Test with various attack scenarios
        const attackScenarios = [
            {
                name: 'Password brute force',
                target: sensitiveData.password,
                attempts: [
                    'h',
                    'highly-',
                    'highly-sensitive-',
                    'highly-sensitive-password',
                    'wrong-password',
                ],
            },
            {
                name: 'Token validation',
                target: sensitiveData.token,
                attempts: [
                    Buffer.from('s'),
                    Buffer.from('secure-'),
                    Buffer.from('secure-authentication-'),
                    Buffer.from('secure-authentication-token'),
                    Buffer.from('invalid-token'),
                ],
            },
            {
                name: 'Hash verification',
                target: sensitiveData.hash,
                attempts: [
                    new Uint8Array([0x1a]),
                    new Uint8Array([0x1a, 0x2b, 0x3c]),
                    new Uint8Array([0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f]),
                    new Uint8Array([0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa]),
                ],
            },
        ];

        attackScenarios.forEach((scenario) => {
            scenario.attempts.forEach((attempt) => {
                const isMatch = constantTimeCompare(scenario.target, attempt);

                // Verify that only exact matches succeed
                let isExactMatch: boolean;

                // Handle different data types properly
                if (typeof scenario.target === 'string' && typeof attempt === 'string') {
                    // String comparison
                    isExactMatch = scenario.target === attempt;
                } else if (Buffer.isBuffer(scenario.target) && Buffer.isBuffer(attempt)) {
                    // Buffer comparison
                    isExactMatch = scenario.target.equals(attempt);
                } else if (
                    scenario.target instanceof Uint8Array &&
                    attempt instanceof Uint8Array
                ) {
                    // Uint8Array comparison
                    if (scenario.target.length !== attempt.length) {
                        isExactMatch = false;
                    } else {
                        isExactMatch = true;
                        for (let i = 0; i < scenario.target.length; i++) {
                            if (scenario.target[i] !== attempt[i]) {
                                isExactMatch = false;
                                break;
                            }
                        }
                    }
                } else {
                    // Convert both to buffers for comparison (matches constantTimeCompare behavior)
                    const bufferA = typeof scenario.target === 'string' ?
                        Buffer.from(scenario.target) : Buffer.from(scenario.target);
                    const bufferB = typeof attempt === 'string' ?
                        Buffer.from(attempt) : Buffer.from(attempt);
                    isExactMatch = bufferA.equals(bufferB);
                }

                expect(isMatch).toBe(isExactMatch);
            });
        });
    });
});
